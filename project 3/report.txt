Jordan Yen
Project 3 Report


1. The name of your recursive goblin movement function and the name of the file it's implemented in, or else a statement that your goblin movement function is not recursive. (Make this the first thing, to help the grader find the function.)
   1. void Goblin::move(Level* level, Player* player) in Monster.cpp
2. a high-level description of your goblin movement function.
   1. The Goblin::move function is designed to determine and execute the movement of a goblin character within a game level towards the player character. The function begins by initializing the maximum distance within which the goblin can "smell" the player, set to 15 units. It retrieves the current coordinates of both the goblin and the player. To facilitate the pathfinding process, the function sets up a 2D vector called dist, which stores the distance from the goblin's starting position to each cell in the level. All distances are initially set to -1 to indicate unvisited cells, except for the goblin's starting position, which is set to 0. The function also defines a vector of possible movement directions (right, down, left, and up). The core of the movement logic is implemented through a recursive depth-first search (DFS) lambda function. This function, dfs, takes the current coordinates and explores each direction. For each possible move, it calculates the new coordinates and checks if these coordinates are within the level's boundaries, unvisited, and walkable. If these conditions are met, it updates the distance for the new cell and recursively calls dfs for this new position. After setting up the DFS, the function initiates it from the goblin's initial position. Upon completion of the DFS, the function checks if the player is within the goblin's smell range and reachable by verifying that the distance to the player's position is not -1 and is within the specified distance. If the player is reachable, the function then determines the next move by finding the neighboring cell of the goblin's current position with the smallest distance to the player. It iterates over each possible direction, updating the nextMove to the cell with the smallest distance. Finally, if the next move differs from the goblin's current position, the function executes the move by calling level->moveMonster, which updates the goblin's position on the game level. This approach ensures that the goblin moves efficiently towards the player while adhering to the constraints of the game environment and the goblin's capabilities.
3. a high-level description of how you generate a level with rooms connected by corridors (or as much as you were able to implement).
   1. The process of generating a level with rooms connected by corridors in the game involves several key steps to ensure a coherent and navigable layout. First, the level grid is initialized with a default character representing walls. A set number of rooms are then generated, with each room having random dimensions and positions within the grid. Before placing a room, the algorithm checks if the space is available and not overlapping with other rooms or outside the grid boundaries. If the space is available, the room is placed by updating the grid cells to represent open space. Once the rooms are placed, corridors are generated to connect them, ensuring the level is fully navigable. Corridors are created by drawing paths between the centers of adjacent rooms, which involves setting grid cells along the path to represent open space. This is done by moving horizontally and then vertically (or vice versa) between the centers of two rooms, ensuring there is a clear path between all rooms. After the basic layout of rooms and corridors is established, additional elements such as stairs, monsters, and game objects are placed. Stairs are usually placed in one of the rooms, providing a way to progress to the next level. Monsters and objects are randomly placed in open spaces within the level, with the positions of these elements stored to ensure they can be interacted with during gameplay. This methodical approach to level generation ensures a balance between randomness and playability, creating varied and interesting levels for the player to explore.
4. A list of all functionality that you didn't finish, as well as known bugs in your implementations or serious inefficiencies, e.g. "I couldn't get goblins to move correctly, so I made them move like Bogeymen."
   1. I was not able to fully implement the recursive function but I did it to the best of my ability.